#!/usr/bin/env python3
"""
Interactive Surfzone Simulation Result Viewer (Plotly Dash)

View forward ray tracing results overlaid on the mesh.
Shows wave heights, coverage, and energy statistics.
Click on points to see detailed statistics.

Usage:
    python scripts/dev/view_surfzone_result.py --region socal
    python scripts/dev/view_surfzone_result.py --region norcal --result-file path/to/result.npz
    python scripts/dev/view_surfzone_result.py --list-regions
    python scripts/dev/view_surfzone_result.py --region socal --lonlat

Ray Visualization:
    When --show-rays is specified, the viewer overlays ray paths on the wave
    height map. Rays are colored by partition (wind_sea=blue, primary_swell=orange,
    secondary_swell=green, tertiary_swell=red).

    Ray paths must first be generated by running the simulation with --track-rays:
        python data/surfzone/runner/run_simulation.py --region socal --mode forward --track-rays

    Examples:
        # Show 100 random rays (default)
        python scripts/dev/view_surfzone_result.py --region socal --show-rays

        # Show 500 rays
        python scripts/dev/view_surfzone_result.py --region socal --show-rays 500

        # Show rays from specific partition only
        python scripts/dev/view_surfzone_result.py --region socal --show-rays 100 --partition primary_swell
"""

import argparse
import sys
from pathlib import Path
from typing import Optional, Dict, Any

import numpy as np
import pandas as pd
from scipy.spatial import cKDTree
from dash import Dash, dcc, html, Input, Output, callback_context
import plotly.graph_objects as go

# Add project root to path
project_root = Path(__file__).parent.parent.parent
sys.path.insert(0, str(project_root))

from data.regions.region import REGIONS


def list_regions_with_results():
    """List regions with their simulation results status."""
    print("\nRegions with simulation results:")
    print("-" * 70)

    for name in ['socal', 'central', 'norcal']:
        region = REGIONS[name]

        # Check for surfzone mesh
        mesh_dir = project_root / "data" / "surfzone" / "meshes" / name
        mesh_exists = mesh_dir.exists() and any(mesh_dir.glob("*.npz"))

        # Check for results in region directory
        result_dir = project_root / "data" / "surfzone" / "output" / name
        results = []
        if result_dir.exists():
            results = sorted(result_dir.glob("*.npz"), key=lambda p: p.stat().st_mtime, reverse=True)

        print(f"  {name:12} - {region.display_name}")
        print(f"               Mesh: {'Yes' if mesh_exists else 'No'}")

        if results:
            print(f"               Results:")
            for r in results[:3]:  # Show first 3
                print(f"                 - {r.name}")
            if len(results) > 3:
                print(f"                 ... and {len(results) - 3} more")
        else:
            print(f"               Results: None")
        print()


def find_result_file(region_name: str, result_file: Optional[Path] = None) -> Path:
    """
    Find result file for a region.

    Args:
        region_name: Region identifier (socal, norcal, central)
        result_file: Explicit path (if provided, used directly)

    Returns:
        Path to result .npz file

    Raises:
        FileNotFoundError: If no results found
    """
    if result_file is not None:
        if not result_file.exists():
            raise FileNotFoundError(f"Result file not found: {result_file}")
        return result_file

    # Try region-specific directory
    region_dir = project_root / "data" / "surfzone" / "output" / region_name
    if region_dir.exists():
        # Try default filenames for forward results (newest name first)
        for default_name in ["forward_result.npz", "forward_energy.npz"]:
            default_result = region_dir / default_name
            if default_result.exists():
                return default_result

        # Fall back to most recent .npz in directory (excluding ray_paths.npz)
        npz_files = sorted(
            [f for f in region_dir.glob("*.npz") if f.name != "ray_paths.npz"],
            key=lambda p: p.stat().st_mtime, reverse=True
        )
        if npz_files:
            return npz_files[0]

    raise FileNotFoundError(
        f"No results found for region '{region_name}'. "
        f"Run simulation first: python data/surfzone/runner/run_simulation.py --region {region_name}"
    )


def load_mesh(region_name: str = "socal"):
    """Load a surf zone mesh."""
    from data.surfzone.mesh import SurfZoneMesh

    mesh_dir = project_root / "data" / "surfzone" / "meshes" / region_name
    if not mesh_dir.exists():
        print(f"Error: Mesh not found at {mesh_dir}")
        sys.exit(1)

    return SurfZoneMesh.load(mesh_dir)


def load_result(result_path: Path):
    """Load forward ray tracing result."""
    from data.surfzone.runner.output_writer import load_forward_result

    if not result_path.exists():
        print(f"Error: Result not found at {result_path}")
        print("Run the simulation first: python data/surfzone/runner/run_simulation.py --region <region>")
        sys.exit(1)

    return load_forward_result(result_path)


def load_partition_data(output_dir: Path) -> Dict[str, Dict[str, np.ndarray]]:
    """Load per-partition data files."""
    partition_names = ['wind_sea', 'primary_swell', 'secondary_swell', 'tertiary_swell']
    partitions = {}

    for name in partition_names:
        path = output_dir / f"{name}.npz"
        if path.exists():
            data = np.load(path)
            partitions[name] = {key: data[key] for key in data.files}
            print(f"  Loaded partition: {name}")

    return partitions


def load_statistics_data(output_dir: Path) -> Optional[pd.DataFrame]:
    """Load statistics CSV file."""
    stats_path = output_dir / "statistics_latest.csv"
    if stats_path.exists():
        df = pd.read_csv(stats_path)
        print(f"  Loaded statistics: {len(df):,} points")
        return df
    return None


def load_ray_paths(output_dir: Path) -> Optional[Dict[str, Any]]:
    """
    Load ray path data from ray_paths.npz.

    Returns:
        Dict with ray path arrays, or None if file doesn't exist
    """
    ray_paths_file = output_dir / "ray_paths.npz"
    if not ray_paths_file.exists():
        return None

    data = np.load(ray_paths_file)
    ray_paths = {key: data[key] for key in data.files}
    n_sampled = int(ray_paths['n_rays_sampled'])
    n_total = int(ray_paths['n_rays_total'])
    sample_pct = float(ray_paths['sample_fraction']) * 100
    print(f"  Loaded ray paths: {n_sampled:,} rays ({sample_pct:.0f}% of {n_total:,})")
    return ray_paths


def create_app(
    result,
    partitions: Dict[str, Dict[str, np.ndarray]],
    statistics: Optional[pd.DataFrame],
    mesh,
    use_lonlat: bool,
    h_max: float,
    ray_paths: Optional[Dict[str, Any]] = None,
    show_rays: int = 0,
    partition_filter: Optional[str] = None,
):
    """Create the Dash app."""

    # Get coordinates
    n_points = result.n_points

    if use_lonlat:
        display_x, display_y = mesh.utm_to_lon_lat(result.mesh_x, result.mesh_y)
        x_label = "Longitude"
        y_label = "Latitude"
    else:
        display_x = result.mesh_x.copy()
        display_y = result.mesh_y.copy()
        x_label = "UTM Easting (m)"
        y_label = "UTM Northing (m)"

    # Coverage mask
    covered_mask = result.ray_count > 0
    not_covered_mask = ~covered_mask
    n_covered = int(np.sum(covered_mask))

    # Create main figure
    fig = go.Figure()

    # Layer 1: Not covered points (gray)
    n_not_covered = int(np.sum(not_covered_mask))
    if n_not_covered > 0:
        fig.add_trace(go.Scattergl(
            x=display_x[not_covered_mask],
            y=display_y[not_covered_mask],
            mode='markers',
            marker=dict(
                size=3,
                color='#444466',
                opacity=0.5,
            ),
            customdata=np.where(not_covered_mask)[0],  # Store original indices
            name='Not covered',
            hoverinfo='skip',
        ))

    # Layer 2: Covered points - colored by wave height
    if n_covered > 0:
        H_values = np.clip(result.H_at_mesh[covered_mask], 0, h_max)
        covered_indices = np.where(covered_mask)[0]

        fig.add_trace(go.Scattergl(
            x=display_x[covered_mask],
            y=display_y[covered_mask],
            mode='markers',
            marker=dict(
                size=4,
                color=H_values,
                colorscale='Viridis',
                colorbar=dict(
                    title='Hs (m)',
                    thickness=15,
                    len=0.7,
                    y=0.5,
                ),
                cmin=0,
                cmax=h_max,
                opacity=0.8,
            ),
            customdata=covered_indices,  # Store original indices
            name='Covered',
            hovertemplate='<extra></extra>',  # Minimal hover, we use click
        ))

    # Add coastlines
    if mesh.coastlines:
        for i, coastline in enumerate(mesh.coastlines):
            if use_lonlat:
                cl_x, cl_y = mesh.utm_to_lon_lat(coastline[:, 0], coastline[:, 1])
            else:
                cl_x, cl_y = coastline[:, 0], coastline[:, 1]

            fig.add_trace(go.Scattergl(
                x=cl_x,
                y=cl_y,
                mode='lines',
                line=dict(color='magenta', width=2),
                name='Coastline' if i == 0 else None,
                showlegend=(i == 0),
                hoverinfo='skip',
            ))

    # Add ray paths if requested
    if ray_paths is not None and show_rays > 0:
        # Partition colors
        partition_colors = {
            0: 'rgba(100, 149, 237, 0.6)',  # Wind sea - cornflower blue
            1: 'rgba(255, 165, 0, 0.6)',    # Primary swell - orange
            2: 'rgba(50, 205, 50, 0.6)',    # Secondary swell - lime green
            3: 'rgba(220, 20, 60, 0.6)',    # Tertiary swell - crimson
        }
        partition_names_map = {
            0: 'wind_sea',
            1: 'primary_swell',
            2: 'secondary_swell',
            3: 'tertiary_swell',
        }
        partition_labels = {
            0: 'Wind Sea',
            1: 'Primary Swell',
            2: 'Secondary Swell',
            3: 'Tertiary Swell',
        }

        n_sampled = int(ray_paths['n_rays_sampled'])
        ray_partition = ray_paths['ray_partition']
        ray_start_idx = ray_paths['ray_start_idx']
        ray_length = ray_paths['ray_length']
        path_x = ray_paths['path_x']
        path_y = ray_paths['path_y']

        # Filter by partition if specified
        if partition_filter:
            partition_id = None
            for pid, pname in partition_names_map.items():
                if pname == partition_filter:
                    partition_id = pid
                    break
            if partition_id is not None:
                valid_rays = np.where(ray_partition == partition_id)[0]
            else:
                valid_rays = np.arange(n_sampled)
        else:
            valid_rays = np.arange(n_sampled)

        # Sample rays to display
        n_to_show = min(show_rays, len(valid_rays))
        if n_to_show < len(valid_rays):
            np.random.seed(42)
            ray_indices = np.random.choice(valid_rays, size=n_to_show, replace=False)
        else:
            ray_indices = valid_rays

        # Group rays by partition for legend
        rays_by_partition = {}
        for idx in ray_indices:
            pid = int(ray_partition[idx])
            if pid not in rays_by_partition:
                rays_by_partition[pid] = []
            rays_by_partition[pid].append(idx)

        # Add traces for each partition
        for pid, indices in sorted(rays_by_partition.items()):
            color = partition_colors.get(pid, 'rgba(128, 128, 128, 0.5)')
            label = partition_labels.get(pid, f'Partition {pid}')

            # Combine all rays in this partition into single trace with None separators
            all_x = []
            all_y = []

            for idx in indices:
                start = int(ray_start_idx[idx])
                length = int(ray_length[idx])
                ray_x = path_x[start:start + length]
                ray_y = path_y[start:start + length]

                # Convert to lon/lat if needed
                if use_lonlat:
                    ray_x, ray_y = mesh.utm_to_lon_lat(ray_x, ray_y)

                all_x.extend(ray_x)
                all_x.append(None)  # Separator
                all_y.extend(ray_y)
                all_y.append(None)  # Separator

            fig.add_trace(go.Scattergl(
                x=all_x,
                y=all_y,
                mode='lines',
                line=dict(color=color, width=1),
                name=f'{label} rays ({len(indices)})',
                hoverinfo='skip',
            ))

    # Layout
    fig.update_layout(
        title=f'Surfzone Simulation: {result.region_name}',
        xaxis_title=x_label,
        yaxis_title=y_label,
        template='plotly_dark',
        paper_bgcolor='#1a1a2e',
        plot_bgcolor='#1a1a2e',
        height=850,
        showlegend=True,
        legend=dict(
            yanchor='top',
            y=0.99,
            xanchor='left',
            x=0.01,
            bgcolor='rgba(26, 26, 46, 0.8)',
        ),
        # Enable scroll zoom
        xaxis=dict(
            scaleanchor='y',
            scaleratio=1,
        ),
        dragmode='zoom',  # Default to zoom mode
        hovermode='closest',
    )

    # Build KD-tree for coordinate-based point lookup (fallback for click handling)
    point_tree = cKDTree(np.column_stack([display_x, display_y]))

    # Prepare data for callbacks (need to store in app)
    app_data = {
        'display_x': display_x,
        'display_y': display_y,
        'mesh_x': result.mesh_x,
        'mesh_y': result.mesh_y,
        'mesh_depth': result.mesh_depth,
        'H_at_mesh': result.H_at_mesh,
        'energy': result.energy,
        'ray_count': result.ray_count,
        'n_points': n_points,
        'use_lonlat': use_lonlat,
        'region_name': result.region_name,
        'n_partitions': result.n_partitions,
        'n_covered': result.n_covered,
        'n_rays_total': result.n_rays_total,
        'coverage_rate': result.coverage_rate,
        'partitions': partitions,
        'statistics': statistics,
        'point_tree': point_tree,  # KD-tree for coordinate lookup
    }

    # Build statistics summary as Dash components
    stats_summary_children = [
        html.H4("Simulation Summary", style={'marginTop': 0}),
        html.P([html.B("Region: "), result.region_name]),
        html.P([html.B("Partitions: "), str(result.n_partitions)]),
        html.P([html.B("Total points: "), f"{result.n_points:,}"]),
        html.P([html.B("Covered: "), f"{result.n_covered:,} ({100*result.coverage_rate:.1f}%)"]),
        html.P([html.B("Rays traced: "), f"{result.n_rays_total:,}"]),
    ]

    if n_covered > 0:
        H_cov = result.H_at_mesh[covered_mask]
        ray_cov = result.ray_count[covered_mask]
        stats_summary_children.extend([
            html.Hr(),
            html.H4("Wave Height (covered)"),
            html.P(f"Min: {np.nanmin(H_cov):.2f}m"),
            html.P(f"Max: {np.nanmax(H_cov):.2f}m"),
            html.P(f"Mean: {np.nanmean(H_cov):.2f}m"),
            html.Hr(),
            html.H4("Rays per point"),
            html.P(f"Min: {ray_cov.min()}"),
            html.P(f"Max: {ray_cov.max()}"),
            html.P(f"Mean: {ray_cov.mean():.1f}"),
        ])

    # Create Dash app
    app = Dash(__name__)

    # Store data in app
    app.app_data = app_data

    # Layout
    app.layout = html.Div([
        # Main content
        html.Div([
            # Left sidebar - stats summary
            html.Div([
                html.H3("Surfzone Viewer", style={'margin': '10px 0'}),
                html.Div([
                    html.Span("Click on any point to inspect", style={'fontSize': '12px', 'color': '#888'}),
                ]),
                html.Hr(),
                html.Div(
                    id='stats-summary',
                    children=stats_summary_children,
                    style={'padding': '10px'},
                ),
            ], style={
                'width': '220px',
                'padding': '10px',
                'backgroundColor': '#2a2a3e',
                'color': 'white',
                'overflowY': 'auto',
                'height': '100vh',
            }),

            # Main plot
            html.Div([
                dcc.Graph(
                    id='main-plot',
                    figure=fig,
                    style={'height': '100%', 'width': '100%'},
                    config={
                        'scrollZoom': True,  # Enable scroll zoom
                        'displayModeBar': True,
                        'modeBarButtonsToAdd': ['zoom2d', 'pan2d', 'zoomIn2d', 'zoomOut2d', 'resetScale2d'],
                    },
                ),
            ], style={
                'flex': '1',
                'height': '100vh',
            }),

            # Right sidebar - point inspector
            html.Div([
                html.H3("Point Inspector", style={'margin': '10px 0'}),
                html.Hr(),
                html.Div(
                    id='point-info',
                    children=[
                        html.P("Click on a point to see details", style={'color': '#888', 'fontSize': '12px'}),
                    ],
                ),
            ], style={
                'width': '280px',
                'padding': '15px',
                'backgroundColor': '#2a2a3e',
                'color': 'white',
                'overflowY': 'auto',
                'height': '100vh',
            }),
        ], style={
            'display': 'flex',
            'flexDirection': 'row',
            'height': '100vh',
            'backgroundColor': '#1a1a2e',
        }),
    ])

    @app.callback(
        Output('point-info', 'children'),
        Input('main-plot', 'clickData'),
    )
    def display_click_data(clickData):
        if clickData is None:
            return html.P("Click on a point to see details", style={'color': '#888', 'fontSize': '12px'})

        # Get data from app
        data = app.app_data

        # Get point index - try customdata first, then fall back to coordinate lookup
        point = clickData['points'][0]
        point_idx = None

        # Try customdata first
        if 'customdata' in point and point['customdata'] is not None:
            try:
                point_idx = int(point['customdata'])
            except (TypeError, ValueError):
                pass

        # Fall back to coordinate-based lookup using KD-tree
        if point_idx is None:
            if 'x' in point and 'y' in point:
                click_x = point['x']
                click_y = point['y']
                _, point_idx = data['point_tree'].query([click_x, click_y])
            else:
                return html.P("Could not determine point location", style={'color': '#888'})

        # Validate index
        if point_idx < 0 or point_idx >= data['n_points']:
            return html.P(f"Invalid point index: {point_idx}", style={'color': '#f88'})

        # Build info display
        info = []

        # Coordinates
        if data['use_lonlat']:
            coord_str = f"Lon: {data['display_x'][point_idx]:.5f}, Lat: {data['display_y'][point_idx]:.5f}"
        else:
            coord_str = f"X: {data['mesh_x'][point_idx]:.0f}m, Y: {data['mesh_y'][point_idx]:.0f}m"

        info.append(html.H4(f"Point #{point_idx:,}", style={'marginTop': 0}))
        info.append(html.P(coord_str))
        info.append(html.P(f"Depth: {data['mesh_depth'][point_idx]:.2f}m"))

        # Check if covered
        ray_count = data['ray_count'][point_idx]
        if ray_count == 0:
            info.append(html.Hr())
            info.append(html.P("Not covered (no rays)", style={'color': '#888', 'fontStyle': 'italic'}))
            return html.Div(info)

        # Combined wave data
        info.append(html.Hr())
        info.append(html.H4("Combined Wave Data"))
        info.append(html.P([html.B("Hs: "), f"{data['H_at_mesh'][point_idx]:.2f}m"]))
        info.append(html.P([html.B("Energy: "), f"{data['energy'][point_idx]:.1f} J/m"]))
        info.append(html.P([html.B("Ray count: "), f"{ray_count}"]))

        # Per-partition data
        partitions = data['partitions']
        if partitions:
            info.append(html.Hr())
            info.append(html.H4("Per-Partition"))

            partition_labels = {
                'wind_sea': 'Wind Sea',
                'primary_swell': 'Primary Swell',
                'secondary_swell': 'Secondary Swell',
                'tertiary_swell': 'Tertiary Swell',
            }

            for name, pdata in partitions.items():
                if 'converged' in pdata and pdata['converged'][point_idx]:
                    label = partition_labels.get(name, name)
                    Hs = pdata['boundary_Hs'][point_idx]
                    Tp = pdata['boundary_Tp'][point_idx]
                    direction = pdata['boundary_direction'][point_idx]

                    info.append(html.Div([
                        html.B(f"{label}:"),
                        html.Br(),
                        html.Span(f"  Hs: {Hs:.2f}m, Tp: {Tp:.1f}s, Dir: {direction:.0f}Â°",
                                 style={'fontSize': '12px'}),
                    ], style={'marginBottom': '8px'}))

        # Wave group statistics
        statistics = data['statistics']
        if statistics is not None:
            stats_row = statistics[statistics['point_id'] == point_idx]
            if len(stats_row) > 0:
                row = stats_row.iloc[0]

                info.append(html.Hr())
                info.append(html.H4("Wave Group Statistics"))

                stat_items = [
                    ('set_period', 'Set period', 's'),
                    ('waves_per_set', 'Waves/set', ''),
                    ('groupiness_factor', 'Groupiness', ''),
                    ('height_amplification', 'Height amp', 'x'),
                    ('set_duration', 'Set duration', 's'),
                    ('lull_duration', 'Lull duration', 's'),
                ]

                for col, label, unit in stat_items:
                    if col in row and not pd.isna(row[col]):
                        val = row[col]
                        if unit:
                            info.append(html.P([html.B(f"{label}: "), f"{val:.2f}{unit}"]))
                        else:
                            info.append(html.P([html.B(f"{label}: "), f"{val:.2f}"]))

        return html.Div(info)

    return app


def view_result(
    result_path: Path = None,
    mesh_region: str = "socal",
    use_lonlat: bool = False,
    h_max: float = None,
    port: int = 8050,
    show_rays: int = 0,
    partition_filter: Optional[str] = None,
):
    """Create and run interactive result viewer."""

    print(f"Loading mesh for {mesh_region}...")
    mesh = load_mesh(mesh_region)
    print(mesh.summary())
    print()

    print("Loading simulation result...")
    result = load_result(result_path)
    print(result.summary())
    print()

    # Load partition and statistics data
    print("Loading additional data...")
    output_dir = result_path.parent
    partitions = load_partition_data(output_dir)
    statistics = load_statistics_data(output_dir)

    # Load ray paths if requested
    ray_paths = None
    if show_rays > 0:
        ray_paths = load_ray_paths(output_dir)
        if ray_paths is None:
            print("  Warning: No ray_paths.npz found. Run simulation with --track-rays to generate.")
    print()

    # Coverage info
    covered_mask = result.ray_count > 0
    n_covered = result.n_covered

    print(f"Result points: {result.n_points:,}")
    print(f"Covered: {n_covered:,} ({100*result.coverage_rate:.1f}%)")

    # Auto-determine wave height max
    if h_max is None:
        if n_covered > 0:
            h_max = float(np.nanpercentile(result.H_at_mesh[covered_mask], 98))
            h_max = max(h_max, 0.5)  # At least 0.5m
        else:
            h_max = 2.0

    print(f"Wave height color scale: 0 - {h_max:.1f}m")
    if show_rays > 0 and ray_paths is not None:
        filter_str = f" ({partition_filter})" if partition_filter else ""
        print(f"Showing {show_rays} ray paths{filter_str}")
    print()

    # Create app
    app = create_app(
        result, partitions, statistics, mesh, use_lonlat, h_max,
        ray_paths=ray_paths, show_rays=show_rays, partition_filter=partition_filter
    )

    print(f"Starting viewer at http://localhost:{port}")
    print("Use Ctrl+C to stop the server")
    print()
    print("Controls:")
    print("  - Scroll: Zoom in/out")
    print("  - Click+drag: Pan (in pan mode) or Box zoom (in zoom mode)")
    print("  - Double-click: Reset view")
    print("  - Click point: Inspect details")
    print()

    app.run(debug=False, port=port)


def main():
    parser = argparse.ArgumentParser(
        description="Interactive surfzone simulation result viewer (Plotly)",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
    python scripts/dev/view_surfzone_result.py --region socal
    python scripts/dev/view_surfzone_result.py --region norcal --lonlat
    python scripts/dev/view_surfzone_result.py --list-regions
    python scripts/dev/view_surfzone_result.py --region socal --result-file path/to/result.npz

Ray visualization:
    python scripts/dev/view_surfzone_result.py --region socal --show-rays
    python scripts/dev/view_surfzone_result.py --region socal --show-rays 500
    python scripts/dev/view_surfzone_result.py --region socal --show-rays 200 --partition primary_swell
        """,
    )

    # Region selection
    parser.add_argument(
        '--region',
        type=str,
        default=None,
        help="Region name (socal, norcal, central). Auto-detects mesh and results."
    )

    parser.add_argument(
        '--list-regions',
        action='store_true',
        help="List regions with available results and exit"
    )

    parser.add_argument(
        '--result-file',
        type=Path,
        default=None,
        help="Path to result .npz file (default: auto-detect for region)"
    )

    parser.add_argument(
        '--h-max',
        type=float,
        default=None,
        help="Maximum wave height for color scale (default: auto)"
    )

    parser.add_argument(
        '--lonlat',
        action='store_true',
        help="Use longitude/latitude coordinates instead of UTM"
    )

    parser.add_argument(
        '--port', '-p',
        type=int,
        default=8050,
        help="Port to run server on (default: 8050)"
    )

    # Ray visualization
    parser.add_argument(
        '--show-rays',
        type=int,
        nargs='?',
        const=100,
        default=0,
        help="Show N ray paths (default: 100 if flag present, 0 otherwise). Requires --track-rays during simulation."
    )

    parser.add_argument(
        '--partition',
        type=str,
        default=None,
        choices=['wind_sea', 'primary_swell', 'secondary_swell', 'tertiary_swell'],
        help="Filter rays to specific partition"
    )

    args = parser.parse_args()

    # Handle --list-regions
    if args.list_regions:
        list_regions_with_results()
        return

    # Determine region
    region_name = args.region
    if region_name is None:
        region_name = "socal"  # Default
        print(f"Note: Using default region '{region_name}'. Use --region to specify.")

    # Find result file
    try:
        result_path = find_result_file(region_name, args.result_file)
        print(f"Using result file: {result_path}")
    except FileNotFoundError as e:
        print(f"Error: {e}")
        sys.exit(1)

    view_result(
        result_path=result_path,
        mesh_region=region_name,
        use_lonlat=args.lonlat,
        h_max=args.h_max,
        port=args.port,
        show_rays=args.show_rays,
        partition_filter=args.partition,
    )


if __name__ == "__main__":
    main()
